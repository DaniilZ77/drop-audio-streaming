// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package generated

import (
	"context"
)

const deleteBeat = `-- name: DeleteBeat :exec
update beats set is_deleted = true where id = $1
`

func (q *Queries) DeleteBeat(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteBeat, id)
	return err
}

const deleteBeatGenres = `-- name: DeleteBeatGenres :exec
delete from beats_genres where beat_id = $1
`

func (q *Queries) DeleteBeatGenres(ctx context.Context, beatID int32) error {
	_, err := q.db.Exec(ctx, deleteBeatGenres, beatID)
	return err
}

const deleteBeatMoods = `-- name: DeleteBeatMoods :exec
delete from beats_moods where beat_id = $1
`

func (q *Queries) DeleteBeatMoods(ctx context.Context, beatID int32) error {
	_, err := q.db.Exec(ctx, deleteBeatMoods, beatID)
	return err
}

const deleteBeatNotes = `-- name: DeleteBeatNotes :exec
delete from beats_notes where beat_id = $1
`

func (q *Queries) DeleteBeatNotes(ctx context.Context, beatID int32) error {
	_, err := q.db.Exec(ctx, deleteBeatNotes, beatID)
	return err
}

const deleteBeatTags = `-- name: DeleteBeatTags :exec
delete from beats_tags where beat_id = $1
`

func (q *Queries) DeleteBeatTags(ctx context.Context, beatID int32) error {
	_, err := q.db.Exec(ctx, deleteBeatTags, beatID)
	return err
}

const getBeatByID = `-- name: GetBeatByID :one
select id, beatmaker_id, file_path, image_path, name, description, is_file_downloaded, is_image_downloaded, is_deleted, created_at, updated_at, bpm from beats where id = $1
`

func (q *Queries) GetBeatByID(ctx context.Context, id int32) (Beat, error) {
	row := q.db.QueryRow(ctx, getBeatByID, id)
	var i Beat
	err := row.Scan(
		&i.ID,
		&i.BeatmakerID,
		&i.FilePath,
		&i.ImagePath,
		&i.Name,
		&i.Description,
		&i.IsFileDownloaded,
		&i.IsImageDownloaded,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Bpm,
	)
	return i, err
}

const getBeatGenreParams = `-- name: GetBeatGenreParams :many
select id, name from genres
`

func (q *Queries) GetBeatGenreParams(ctx context.Context) ([]Genre, error) {
	rows, err := q.db.Query(ctx, getBeatGenreParams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Genre
	for rows.Next() {
		var i Genre
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBeatMoodParams = `-- name: GetBeatMoodParams :many
select id, name from moods
`

func (q *Queries) GetBeatMoodParams(ctx context.Context) ([]Mood, error) {
	rows, err := q.db.Query(ctx, getBeatMoodParams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Mood
	for rows.Next() {
		var i Mood
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBeatNoteParams = `-- name: GetBeatNoteParams :many
select id, name from notes
`

func (q *Queries) GetBeatNoteParams(ctx context.Context) ([]Note, error) {
	rows, err := q.db.Query(ctx, getBeatNoteParams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBeatTagParams = `-- name: GetBeatTagParams :many
select id, name from tags
`

func (q *Queries) GetBeatTagParams(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.Query(ctx, getBeatTagParams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveBeat = `-- name: SaveBeat :exec
insert into beats ("id", "beatmaker_id", "bpm", "description", "name", "file_path", "image_path")
values ($1, $2, $3, $4, $5, $6, $7)
`

type SaveBeatParams struct {
	ID          int32
	BeatmakerID int32
	Bpm         int32
	Description string
	Name        string
	FilePath    string
	ImagePath   string
}

func (q *Queries) SaveBeat(ctx context.Context, arg SaveBeatParams) error {
	_, err := q.db.Exec(ctx, saveBeat,
		arg.ID,
		arg.BeatmakerID,
		arg.Bpm,
		arg.Description,
		arg.Name,
		arg.FilePath,
		arg.ImagePath,
	)
	return err
}

type SaveGenresParams struct {
	BeatID  int32
	GenreID int32
}

type SaveMoodsParams struct {
	BeatID int32
	MoodID int32
}

const saveNote = `-- name: SaveNote :exec
insert into beats_notes ("beat_id", "note_id", "scale")
values ($1, $2, $3)
`

type SaveNoteParams struct {
	BeatID int32
	NoteID int32
	Scale  Scale
}

func (q *Queries) SaveNote(ctx context.Context, arg SaveNoteParams) error {
	_, err := q.db.Exec(ctx, saveNote, arg.BeatID, arg.NoteID, arg.Scale)
	return err
}

type SaveTagsParams struct {
	BeatID int32
	TagID  int32
}

const updateBeat = `-- name: UpdateBeat :one
update beats
set "name" = coalesce($1, "name"),
    "bpm" = coalesce($2, "bpm"),
    "description" = coalesce($3, "description"),
    "is_image_downloaded" = coalesce($4, "is_image_downloaded"),
    "is_file_downloaded" = coalesce($5, "is_file_downloaded")
where "id" = $6 and "is_deleted" = false
returning id, beatmaker_id, file_path, image_path, name, description, is_file_downloaded, is_image_downloaded, is_deleted, created_at, updated_at, bpm
`

type UpdateBeatParams struct {
	Name              *string
	Bpm               *int32
	Description       *string
	IsImageDownloaded *bool
	IsFileDownloaded  *bool
	ID                int32
}

func (q *Queries) UpdateBeat(ctx context.Context, arg UpdateBeatParams) (Beat, error) {
	row := q.db.QueryRow(ctx, updateBeat,
		arg.Name,
		arg.Bpm,
		arg.Description,
		arg.IsImageDownloaded,
		arg.IsFileDownloaded,
		arg.ID,
	)
	var i Beat
	err := row.Scan(
		&i.ID,
		&i.BeatmakerID,
		&i.FilePath,
		&i.ImagePath,
		&i.Name,
		&i.Description,
		&i.IsFileDownloaded,
		&i.IsImageDownloaded,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Bpm,
	)
	return i, err
}
