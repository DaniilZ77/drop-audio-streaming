// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: queries.sql

package generated

import (
	"context"

	"github.com/google/uuid"
)

const deleteBeat = `-- name: DeleteBeat :exec
update beats
set "is_deleted" = true,
    "updated_at" = now()
where id = $1
`

func (q *Queries) DeleteBeat(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteBeat, id)
	return err
}

const deleteBeatGenres = `-- name: DeleteBeatGenres :exec
delete from beats_genres where beat_id = $1
`

func (q *Queries) DeleteBeatGenres(ctx context.Context, beatID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteBeatGenres, beatID)
	return err
}

const deleteBeatMoods = `-- name: DeleteBeatMoods :exec
delete from beats_moods where beat_id = $1
`

func (q *Queries) DeleteBeatMoods(ctx context.Context, beatID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteBeatMoods, beatID)
	return err
}

const deleteBeatNotes = `-- name: DeleteBeatNotes :exec
delete from beats_notes where beat_id = $1
`

func (q *Queries) DeleteBeatNotes(ctx context.Context, beatID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteBeatNotes, beatID)
	return err
}

const deleteBeatTags = `-- name: DeleteBeatTags :exec
delete from beats_tags where beat_id = $1
`

func (q *Queries) DeleteBeatTags(ctx context.Context, beatID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteBeatTags, beatID)
	return err
}

const getBeatByID = `-- name: GetBeatByID :one
select id, beatmaker_id, file_path, image_path, archive_path, name, description, is_file_downloaded, is_image_downloaded, is_archive_downloaded, range_start, range_end, is_deleted, created_at, updated_at, bpm from beats where id = $1
`

func (q *Queries) GetBeatByID(ctx context.Context, id uuid.UUID) (Beat, error) {
	row := q.db.QueryRow(ctx, getBeatByID, id)
	var i Beat
	err := row.Scan(
		&i.ID,
		&i.BeatmakerID,
		&i.FilePath,
		&i.ImagePath,
		&i.ArchivePath,
		&i.Name,
		&i.Description,
		&i.IsFileDownloaded,
		&i.IsImageDownloaded,
		&i.IsArchiveDownloaded,
		&i.RangeStart,
		&i.RangeEnd,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Bpm,
	)
	return i, err
}

const getBeatGenreParams = `-- name: GetBeatGenreParams :many
select id, name from genres
`

func (q *Queries) GetBeatGenreParams(ctx context.Context) ([]Genre, error) {
	rows, err := q.db.Query(ctx, getBeatGenreParams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Genre
	for rows.Next() {
		var i Genre
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBeatMoodParams = `-- name: GetBeatMoodParams :many
select id, name from moods
`

func (q *Queries) GetBeatMoodParams(ctx context.Context) ([]Mood, error) {
	rows, err := q.db.Query(ctx, getBeatMoodParams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Mood
	for rows.Next() {
		var i Mood
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBeatNoteParams = `-- name: GetBeatNoteParams :many
select id, name from notes
`

func (q *Queries) GetBeatNoteParams(ctx context.Context) ([]Note, error) {
	rows, err := q.db.Query(ctx, getBeatNoteParams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Note
	for rows.Next() {
		var i Note
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBeatTagParams = `-- name: GetBeatTagParams :many
select id, name from tags
`

func (q *Queries) GetBeatTagParams(ctx context.Context) ([]Tag, error) {
	rows, err := q.db.Query(ctx, getBeatTagParams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tag
	for rows.Next() {
		var i Tag
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnerByBeatID = `-- name: GetOwnerByBeatID :one
select beat_id, user_id from beats_owners where beat_id = $1
`

func (q *Queries) GetOwnerByBeatID(ctx context.Context, beatID uuid.UUID) (BeatsOwner, error) {
	row := q.db.QueryRow(ctx, getOwnerByBeatID, beatID)
	var i BeatsOwner
	err := row.Scan(&i.BeatID, &i.UserID)
	return i, err
}

const saveBeat = `-- name: SaveBeat :exec
insert into beats ("id", "beatmaker_id", "bpm", "description", "name", "file_path", "image_path", "archive_path", "range_start", "range_end")
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
`

type SaveBeatParams struct {
	ID          uuid.UUID
	BeatmakerID uuid.UUID
	Bpm         int32
	Description string
	Name        string
	FilePath    string
	ImagePath   string
	ArchivePath string
	RangeStart  int64
	RangeEnd    int64
}

func (q *Queries) SaveBeat(ctx context.Context, arg SaveBeatParams) error {
	_, err := q.db.Exec(ctx, saveBeat,
		arg.ID,
		arg.BeatmakerID,
		arg.Bpm,
		arg.Description,
		arg.Name,
		arg.FilePath,
		arg.ImagePath,
		arg.ArchivePath,
		arg.RangeStart,
		arg.RangeEnd,
	)
	return err
}

type SaveGenresParams struct {
	BeatID  uuid.UUID
	GenreID uuid.UUID
}

type SaveMoodsParams struct {
	BeatID uuid.UUID
	MoodID uuid.UUID
}

const saveNote = `-- name: SaveNote :exec
insert into beats_notes ("beat_id", "note_id", "scale")
values ($1, $2, $3)
`

type SaveNoteParams struct {
	BeatID uuid.UUID
	NoteID uuid.UUID
	Scale  NoteScale
}

func (q *Queries) SaveNote(ctx context.Context, arg SaveNoteParams) error {
	_, err := q.db.Exec(ctx, saveNote, arg.BeatID, arg.NoteID, arg.Scale)
	return err
}

const saveOwner = `-- name: SaveOwner :exec
insert into beats_owners ("beat_id", "user_id") values ($1, $2)
`

type SaveOwnerParams struct {
	BeatID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) SaveOwner(ctx context.Context, arg SaveOwnerParams) error {
	_, err := q.db.Exec(ctx, saveOwner, arg.BeatID, arg.UserID)
	return err
}

type SaveTagsParams struct {
	BeatID uuid.UUID
	TagID  uuid.UUID
}

const updateBeat = `-- name: UpdateBeat :one
update beats
set "name" = coalesce($1, "name"),
    "bpm" = coalesce($2, "bpm"),
    "description" = coalesce($3, "description"),
    "range_start" = coalesce($4, "range_start"),
    "range_end" = coalesce($5, "range_end"),
    "is_image_downloaded" = coalesce($6, "is_image_downloaded"),
    "is_file_downloaded" = coalesce($7, "is_file_downloaded"),
    "is_archive_downloaded" = coalesce($8, "is_archive_downloaded"),
    "updated_at" = now()
where "id" = $9 and "is_deleted" = false
returning id, beatmaker_id, file_path, image_path, archive_path, name, description, is_file_downloaded, is_image_downloaded, is_archive_downloaded, range_start, range_end, is_deleted, created_at, updated_at, bpm
`

type UpdateBeatParams struct {
	Name                *string
	Bpm                 *int32
	Description         *string
	RangeStart          *int64
	RangeEnd            *int64
	IsImageDownloaded   *bool
	IsFileDownloaded    *bool
	IsArchiveDownloaded *bool
	ID                  uuid.UUID
}

func (q *Queries) UpdateBeat(ctx context.Context, arg UpdateBeatParams) (Beat, error) {
	row := q.db.QueryRow(ctx, updateBeat,
		arg.Name,
		arg.Bpm,
		arg.Description,
		arg.RangeStart,
		arg.RangeEnd,
		arg.IsImageDownloaded,
		arg.IsFileDownloaded,
		arg.IsArchiveDownloaded,
		arg.ID,
	)
	var i Beat
	err := row.Scan(
		&i.ID,
		&i.BeatmakerID,
		&i.FilePath,
		&i.ImagePath,
		&i.ArchivePath,
		&i.Name,
		&i.Description,
		&i.IsFileDownloaded,
		&i.IsImageDownloaded,
		&i.IsArchiveDownloaded,
		&i.RangeStart,
		&i.RangeEnd,
		&i.IsDeleted,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Bpm,
	)
	return i, err
}
